# featureExtractorMEC.py
"""
Implementation of MEC feature extraction method.
Feature extraction method using minimum energy combination based on:
Friman, Ola, Ivan Volosyak, and Axel Graser. "Multiple channel
detection of steady-state visual evoked potentials for brain-computer
interfaces." IEEE transactions on biomedical engineering 54.4 (2007).
"""
from .featureExtractorTemplateMatching import FeatureExtractorTemplateMatching
import mlx.core as mx  # Main MLX library
import numpy as np     # Still needed for some operations

class FeatureExtractorMEC(FeatureExtractorTemplateMatching):
    """Class of minimum energy combination feature extractor"""
    
    def __init__(self):
        """MEC feature extractor class constructor"""
        super().__init__()
        
        # Force CPU usage with MLX for this instance
        mx.set_default_device(mx.cpu)
        
        # The order of the AR model used for estimating noise energy.
        # This must be a single positive integer. The order of the AR cannot
        # be more than the signal length. 
        self.ar_order = 15
        
        # The ratio of noise energy remained in the projected signal.
        # This must be a number between 0 and 1. 
        self.energy_ratio = 0.05
        
        # A temporary pre-computed value. 
        self.xplus = 0
        
        # The pseudo-inverse of each [sine, cosine] pair for each harmonic
        self.sub_template_inverse = 0   
       
    def setup_feature_extractor(
            self, 
            harmonics_count,
            targets_frequencies,
            sampling_frequency,
            ar_order=15,
            energy_ratio=0.05,
            embedding_dimension=0,
            delay_step=0,
            filter_order=0,
            filter_cutoff_low=0,
            filter_cutoff_high=0,
            subbands=None,
            voters_count=1,
            random_seed=0,
            use_gpu=False,
            max_batch_size=16,
            explicit_multithreading=0,
            samples_count=0):
        """
        Setup the feature extractor parameters (MEC).
        
        Mandatory Parameters:
        ---------------------
        harmonics_count: The number of harmonics to be used in constructing
        the template signal.  This variable must be a positive integer 
        number (typically a value from 3 to 5).  
        
        targets_frequencies: The stimulation freqeuency of each target.  
        This must be a 1D array,  where the first element is the stimulation
        frequency of the first target, the second element is the stimulation
        frequency of the second target, and so on.  The length of this array
        indicates the number of targets.  The user must determine the 
        targets_frequencies but the number of targets (targets_count) is 
        extracted automatically from the length of targets_frequencies. 
        
        sampling_frequency: The sampling rate of the signal 
        (in samples per second).  It must be a real positive value. 
        
        
        Optional Parameters:
        --------------------
        ar_order: This defines the order of the auto-regressive model, which
        is used to compute the expected energy of the noise.  This must be a
        positive integer. 
        
        energy_ratio: This define the ratio of the nuisance signal that is 
        kept in the projected channels.  This must be a real number between
        zero and one.  Reducing this ratio, reduces the energy of the nuisance
        signal but also leads to the loss of information. 
        
        embedding_dimension: This is the dimension of time-delay embedding. 
        This must be a non-negative integer.  If set to zero, no time-dely
        embedding will be used.  If there are E electrodes and we set the 
        embedding_dimension to n, the class expands the input signal as if we
        had n*E channels.  The additional channels are generated by shift_left
        operator.  The number of samples that we shift each signal is 
        controlled by delay_step.  Embedding delays truncates the signal. 
        Make sure the signal is long enough. 
        
        delay_step: The number of samples that are shifted for each delay
        embedding dimension.  For example, assume we have ten channels, 
        embedding_dimension is two, and delay_step is three.  In this case, the
        class creates 30 channels.  The first ten channels are the original
        signals coming from the ten electrodes.  The second ten signals are
        obtained by shifting the origianl signals by three samples.  The third
        ten signals are obtained by shifting the original signals by six 
        samples.  The signals are truncated accordingly. 
        
        filter_order: The order of the filter used for filtering signals before
        analysis.  If filter_order is zero (the default value), no filtering
        is performed.  Otherwise, the class creates a filter of order 
        filter_order.  This must be positive integer. 
        
        cutoff_frequency_low: The first cutoff frequency of the bandpass 
        filter.  This must be a single real positive number.  If filter_order
        is zero, this attribute is ignored.  
        
        cutoff_frequency_high: The second cutoff frequency of the bandpass
        filter. This must be a single real positive number.  If filter_order
        is zero, this attribute is ignored.  
        
        subbands: This is the primary way to instruct the classifier whether 
        to use filterbank or not.  The default value is None.  If set to None, 
        the classifier uses none-fitlerbank implementation.  To use
        filterbanks, subbands must be set to a 2D array, whith exactly two 
        columns.  Each row of this matrix defines a subband with two 
        frequencies provided in two columns.  The first column is the first
        cutoff frequency and the second column is the second cutoff frequency
        of that subband.  Filterbank filters the signal using a bandpass
        filter with these cutoff frequencies to obtain a new subband.  The
        number of rows in the matrix defines the number of subbands. All
        frequencies must be in Hz.  For each row, the second column must
        always be greater than the first column. 
        
        voters_count: The number of electrode-selections that are used for
        classification.  This must be a positive integer.  This is the 
        same as the number of voters.  If voters_count is larger that the 
        cardinality of the power set of the current selected electrodes, 
        then at least one combination is bound to happen more than once. 
        However, because the selection is random, even if voters_count is
        less than the cardinality of the power set, repettitions are still
        possible (although unlikely). If not specified or 1, no 
        voting will be used. 
        
        random_seed: This parameter control the seed for random selection 
        of electrodes.  This must be set to a non-negative integer.  The 
        default value is zero.
        
        use_gpu: When set to 'True,' the class uses a gpu to extract features.
        The host must be equipped with a CUDA-capable GPU.  When set to
        'False,' all processing will be on CPU. 
        
        max_batch_size: The maximum number of signals/channel selections
        that are processed in one batch.  Increasing this number improves
        parallelization at the expense of more memory requirement.  
        This must be a single positve integer. 
        
        explicit_multithreading: This parameter determines whether to use 
        explicit multithreading or not.  If set to a non-positive integer, 
        no multithreading will be used.  If set to a positive integer, the 
        class creates multiple threads to process signals/voters in paralle.
        The number of threads is the same as the value of this variable. 
        E.g., if set to 4, the class distributes the workload among four 
        threads.  Typically, this parameter should be the same as the number
        of cores the cput has, if multithreading is to be used. 
        Multithreading cannot be used when use_gpu is set to True.
        If multithreading is set to a positive value while used_gpu is 
        set to True or vice versa, the classes raises an error and the 
        program terminates. 
        
        samples_count: If provided, the class performs precomputations that
        only depend on the number of samples, e.g., computing the template
        signal.  If not provided, the class does not perform precomputations.
        Instead, it does the computations once the input signal was provided 
        and the class learns the number of samples from the input signal. 
        Setting samples_count is highly recommended.  If the feaure extraction
        method is being used in loop (e.g., BCI2000 loop), setting this 
        parameter eliminates the need to compute the template matrix each
        time. It also helps the class to avoid other computations in each
        iteration. samples_count passed to this function must be the same 
        as the third dimension size of the signal passed to extract_features().
        If that is not the case, the template and input signal will have 
        different dimensions.  The class should issue an error in this case
        and terminate the execution. 
        """
        self.build_feature_extractor(
            harmonics_count,
            targets_frequencies,
            sampling_frequency,
            subbands=subbands,           
            embedding_dimension=embedding_dimension,
            delay_step=delay_step,
            filter_order=filter_order,
            filter_cutoff_low=filter_cutoff_low,
            filter_cutoff_high=filter_cutoff_high,
            voters_count=voters_count,
            random_seed=random_seed,
            use_gpu=use_gpu,
            max_batch_size=max_batch_size,
            explicit_multithreading=explicit_multithreading,
            samples_count=samples_count)
        
        self.ar_order = ar_order
        self.energy_ratio = energy_ratio
            
    def get_features(self, device):
        """Extract MEC features (SNRs) from signal"""    
        # Extract current batch of data
        signal, y_bar_squared = self.get_current_data_batch()
        
        # Swap dimensions for samples and electrodes
        signal = mx.transpose(signal, (0, 2, 1))         
        
        # Extract SNRs                   
        features = self.compute_snr(signal, y_bar_squared)
               
        batch_size = self.channel_selection_info_bundle[1]
        
        # De-bundle the results
        features = mx.reshape(features, (
            features.shape[0]//batch_size,
            batch_size,
            self.targets_count,
            self.features_count)
            )
        
        return features
    
    def get_features_multithreaded(self, signal):
        """Extract MEC features (SNRs) from signal"""        
        # Normalize signal
        signal = signal - mx.mean(signal, axis=-1)[:, None]
        signal = signal / mx.std(signal, axis=-1)[:, None]
        signal = mx.transpose(signal)
        signal = signal[None, :, :]
        
        # Compute Ybar per Eq. (9)
        y_bar = signal - mx.matmul(self.xplus, signal)
        
        y_bar_squared = mx.matmul(
            mx.transpose(y_bar, (0, 2, 1)), y_bar)
        
        y_bar_squared = y_bar_squared[None, :, :, :]                             
        features = self.compute_snr(signal, y_bar_squared)    

        # De-bundle the results
        features = mx.reshape(features, (
            1, 
            1,
            1,
            self.targets_count,
            1))        
        return features
       
    def compute_snr(self, signal, y_bar_squared):
        """Compute the SNR"""         
        # Project signal to minimize nuisance power
        projected_signal, n_s = self.project_signal(signal, y_bar_squared)    
        
        # Compute signal power
        template = self.template_signal_handle[0][None, :, :, :]
        template = mx.transpose(template, (0, 1, 3, 2))
        power = mx.matmul(template, projected_signal)
        power = mx.square(power)
        
        # Add each row to row below it and save in top row
        # One row for sine, one for cosine
        power = power + mx.roll(power, -1, axis=2)
        power = power[:, :, 0:-1:2]
        power = mx.transpose(power, (2, 0, 1, 3))    

        x_inverse_signal = mx.matmul(
            self.sub_template_inverse_handle[0][:, None, :, :, :], 
            projected_signal[None, :, :, :, :])
        
        x = mx.reshape(
            self.template_signal_handle[0], 
            self.template_signal_handle[0].shape[0:-1] + (-1, 2))
        
        x = mx.transpose(x, (2, 0, 1, 3))
        s_bar = mx.matmul(x[:, None, : , :, :], x_inverse_signal)
        s_bar = projected_signal[None, :, :, :, :] - s_bar
        s_bar = mx.transpose(s_bar, (0, 1, 2, 4, 3))        
        
        # Extract noise energy 
        coefficients, noise_energy = self.yule_walker(s_bar)
        sigma_bar = self.k2_handle[0] * noise_energy
        
        # Initialize denominator with complex zeros
        denominator = mx.zeros(coefficients.shape[0:-1], dtype=mx.float32)
        coefficients = mx.transpose(coefficients, (3, 0, 1, 2, 4))
        coefficients = coefficients * -1
        
        coefficients = mx.multiply(
            coefficients, self.k3_handle[0][None, :, None, :, :])
        
        denominator = mx.sum(coefficients, axis=-1)
        denominator = mx.transpose(denominator, (1, 2, 3, 0))
        denominator = mx.abs(1 + denominator) 
        sigma_bar = sigma_bar / denominator
        power = power / sigma_bar
        
        # For each signal, keep only first n_s channels
        snrs = mx.sum(power, axis=0)
        snrs = mx.cumsum(snrs, axis=-1)    

        snrs_reshaped = mx.reshape(snrs, (-1, snrs.shape[2]))
        ns = 1 + mx.arange(snrs_reshaped.shape[-1])
        ns = mx.multiply(mx.ones(snrs_reshaped.shape), ns[None, :])
        ns = (ns == (n_s.flatten())[:, None])
        snrs_reshaped = mx.array([s for s, n in zip(snrs_reshaped, ns) if n])
        snrs = mx.reshape(snrs_reshaped, snrs.shape[0:2])
        
        return snrs
                            
    def project_signal(self, signal, y_bar_squared):
        """Project signal such that noise has minimum energy"""          
        # Compute eigenvalues/vectors for optimization problem
        eigen_values, eigen_vectors = mx.linalg.eigh(y_bar_squared)
        
        # Compute channel count based on desired energy of retained noise
        n_s = self.compute_channels_count(eigen_values)
        
        # Normalize eigenvectors
        eigen_values = mx.sqrt(eigen_values)
        eigen_values = mx.expand_dims(eigen_values, 3)       
        eigen_vectors = mx.transpose(eigen_vectors, (0, 1, 3, 2))
        eigen_vectors = eigen_vectors / eigen_values
        eigen_vectors = mx.transpose(eigen_vectors, (0, 1, 3, 2))
        
        # Keep max channels in batch and discard rest later
        max_index = mx.max(n_s)
        eigen_vectors = eigen_vectors[:, :, :, 0:max_index]
        
        # Compute projected signal per Eq. (7)
        projected_signal = mx.matmul(signal[:, None, :, :], eigen_vectors)            
        return projected_signal, n_s
    
    def compute_channels_count(self, eigen_values):
        """Compute channel count based on energy ratio"""
        # Implementation of Eq. (12)
        running_sum = mx.cumsum(eigen_values, axis=-1)
        total_energy = mx.expand_dims(running_sum[:, :, -1], -1)
        energy_ratio = running_sum / total_energy
        flags = (energy_ratio <= self.energy_ratio_handle[0])        
        n_s = mx.sum(flags, axis=-1)        
        n_s = mx.array([1 if x == 0 else x for x in n_s])
        return n_s
        
    def yule_walker(self, time_series):       
        """Yule-Walker AR model estimation"""            
        p = self.ar_order

        # Initialize r
        r = mx.zeros((p+1,) + time_series.shape[0:-1], dtype=mx.float32)                
        r = r.at[0].set(mx.sum(mx.square(time_series), axis=-1))
    
        # Compute autocorrelations
        for k in range(1, p+1): 
            r = r.at[k].set(mx.sum(mx.multiply(
                time_series[:, :, :, :, :-k], 
                time_series[:, :, :, :, k:]),
                axis=-1))
           
        r = mx.transpose(r, (1, 2, 3, 4, 0))
        r = r / self.samples_count_handle[0]  
        
        # Build Toeplitz matrix
        G = mx.zeros(r.shape[:-1] + (p, p), dtype=mx.float32) 
        G = G.at[:, :, :, :, 0, :].set(r[:, :, :, :, :-1])
        
        for i in range(1, p):
            G = G.at[:, :, :, :, i, i:].set(r[:, :, :, :, :-i-1])
          
        # Construct final matrix using transformation:
        # (1/a0)A = GGT - (G - I)(G - I)T = G + GT - I
        A = G / (G[:, :, :, :, 0, 0])[:, :, :, :, None, None]
        A = A + mx.transpose(A, (0, 1, 2, 3, 5, 4))
        A = A - mx.eye(A.shape[-1], dtype=mx.float32)
        R = A * (G[:, :, :, :, 0, 0])[:, :, :, :, None, None]
        
        # Solve system and compute noise
        rho = mx.linalg.solve(R, r[:, :, :, :, 1:])
        sigmasq = mx.sum(mx.multiply(r[:, :, :, :, 1:], rho), axis=-1)
        sigmasq = r[:, :, :, :, 0] - sigmasq     
        
        return rho, sigmasq
    
    def perform_voting_initialization(self, device=0):
        """Initialize voting operations"""              
        # Normalize data
        self.all_signals = self.all_signals - mx.mean(self.all_signals, axis=-1)[:, :, None]
        self.all_signals = self.all_signals / mx.std(self.all_signals, axis=-1)[:, :, None]
        
        # Create handle for normalized data
        self.all_signals_handle = self.handle_generator(self.all_signals)
        
        # Skip if multithreaded
        if self.explicit_multithreading > 0:
            return
        
        # Pre-compute y_bar per Eq. (9)
        signal = self.all_signals_handle[0]
        signal = mx.transpose(signal, (0, 2, 1))
        
        # Initialize y_bar
        y_bar = mx.zeros(
            (self.signals_count,
             self.targets_count,
             self.samples_count,
             self.electrodes_count), dtype=mx.float32)
        
        # Compute for each signal
        for i in range(self.signals_count):
            y_bar = y_bar.at[i].set(mx.matmul(
                self.xplus_handle[0],
                signal[i, :, :]))
            
        y_bar = signal[:, None, :, :] - y_bar
                  
        self.y_bar_squared = mx.matmul(
            mx.transpose(y_bar, (0, 1, 3, 2)), y_bar)
        
        # Create handle
        self.y_bar_squared_handles = self.handle_generator(self.y_bar_squared)
        
    def class_specific_initializations(self):
        """Perform necessary initializations"""
        # Compute templates
        self.compute_templates()  
        
        # Get harmonic inverses for SNR
        self.precompute_each_harmonic_inverse()
        
        self.xplus = mx.matmul(
            self.template_signal,
            mx.array(np.linalg.pinv(self.template_signal.numpy())))
                
        # Compute constants for SNR
        k1 = ((-2j * mx.pi / self.sampling_frequency)
              * self.targets_frequencies)
        k1 = mx.multiply(
            k1[:, None], (mx.arange(1, self.ar_order+1)[:, None]).T)
        k2 = mx.pi * self.samples_count / 4
        harmonics_scaler = mx.arange(1, self.harmonics_count+1)
        k3 = mx.multiply(harmonics_scaler[:, None, None], k1)
        k3 = mx.exp(k3)        
        self.k3 = k3
        self.k2 = k2
        
        # Create handles
        self.template_signal_handle = self.handle_generator(
            self.template_signal) 
        
        self.sub_template_inverse_handle = self.handle_generator(
            self.sub_template_inverse)
        
        self.xplus_handle = self.handle_generator(self.xplus)
        self.k2_handle = self.handle_generator(self.k2)
        self.k3_handle = self.handle_generator(self.k3)
        self.energy_ratio_handle = self.handle_generator(self.energy_ratio)           
        self.samples_count_handle = self.handle_generator(self.samples_count)
                   
    def precompute_each_harmonic_inverse(self):
        """Pre-compute the inverse of each harmonic"""
        # Saves ~5% performance
        # Extract sine/cosine pair of each harmonic and compute inverse
        self.sub_template_inverse = mx.zeros(
            (self.harmonics_count,
             self.template_signal.shape[0],
             2,
             self.template_signal.shape[1]))
        
        for h in range(0, self.harmonics_count*2, 2):
            x = self.template_signal[:, :, (h, h+1)]
            # Need to use numpy for pinv since MLX doesn't have it yet
            x_inv = np.linalg.pinv(x.numpy())
            self.sub_template_inverse = self.sub_template_inverse.at[h//2].set(
                mx.array(x_inv))
            
    def get_current_data_batch(self):
        """Bundle data for batch processing"""
        # Extract bundle info for readability
        batch_index = self.channel_selection_info_bundle[0]        
        batch_population = self.channel_selection_info_bundle[1]
        batch_electrodes_count = self.channel_selection_info_bundle[2]
        first_signal = self.channel_selection_info_bundle[3]
        last_signal = self.channel_selection_info_bundle[4]
        signals_count = last_signal - first_signal
        
        # Pre-allocate memory for batch
        signal = mx.zeros(
            (signals_count, batch_population,
             batch_electrodes_count, self.samples_count),
            dtype=mx.float32)        
                
        y_bar_squared = mx.zeros(
            (signals_count, batch_population, self.targets_count, 
             batch_electrodes_count, batch_electrodes_count),
            dtype=mx.float32)
        
        selected_signals = self.all_signals_handle[0][first_signal:last_signal]  
        selected_ybar = self.y_bar_squared_handles[0][first_signal:last_signal]
    
        for j in range(batch_population):
            current_selection = self.channel_selections[batch_index]
            signal = signal.at[:, j].set(
                selected_signals[:, current_selection, :])     
            ybar2 = selected_ybar[:, :, current_selection, :]
            ybar2 = ybar2[:, :, :, current_selection]     
            y_bar_squared = y_bar_squared.at[:, j].set(ybar2)
            batch_index += 1
            
        signal = mx.reshape(signal, (-1,) + signal.shape[2:])
        y_bar_squared = mx.reshape(
            y_bar_squared, (-1,) + y_bar_squared.shape[2:])
            
        return (signal, y_bar_squared)
                      
    @property
    def ar_order(self):
        """Getter for AR model order"""
        return self.__ar_order
    
    @ar_order.setter
    def ar_order(self, order):
        """Setter for AR model order"""
        error_message = "Order of the AR model must be a positive integer."
        
        try:
            order = int(order)
        except (ValueError, TypeError):
            self.quit(error_message)
            
        if order <= 0:
            self.quit(error_message)     
            
        self.__ar_order = order
        
    @property
    def energy_ratio(self):
        """Getter for energy ratio"""
        return self.__energy_ratio
    
    @energy_ratio.setter
    def energy_ratio(self, energy_ratio):
        """Setter for energy ratio"""
        error_message = "Energy ratio must be a real number between 0 and 1"
        
        try:
            energy_ratio = float(energy_ratio)
        except (ValueError, TypeError):
            self.quit(error_message)
            
        if not 0 < energy_ratio < 1:
            self.quit(error_message)    
            
        self.__energy_ratio = energy_ratio